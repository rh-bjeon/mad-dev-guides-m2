= 2. 리팩토링 - 40분
:imagesdir: ../assets/images

== 이 랩의 목표

이 랩의 목표는 이전 연습에서 발견한 `customers` 애플리케이션과 관련된 현대화 문제를 이해하고 코드 수정을 통해 이를 해결하는 방법을 배우는 것입니다. MTA 분석 보고서는 또한 각 문제에 대한 *파일 이름*, *경로* 및 *솔루션 권장사항* 측면에서 세부 정보를 제공합니다.

마지막으로 MTA 분석을 사용하여 고객 애플리케이션을 다시 분석하여 문제가 성공적으로 해결되었는지 확인합니다.

== 2.1. 마이그레이션 문제 탐색

이전 모듈의 분석 결과에 따르면 마이그레이션 문제는 *하드코딩된 정적 IP 주소* 를 사용하는 외부 구성과 관련이 있습니다.

image::static-ip-issue.png[정적-ip-문제]

코드 수준에서 문제를 살펴보겠습니다. VS Code 서버 창에서 `customers-tomcat-legacy` 프로젝트를 열고 *src/main/java/io/konveyor/demo/ordermanagement/config* 디렉토리에서 `PersistenceConfig.java` 파일을 찾습니다.

image::persistence-class.png[지속성-클래스]

`dataSource()` 메서드는 _driverClassName_, _url_, _user_, _password_ 와 같은 JDBC 변수를 구성하기 위해 `ApplicationConfiguration` 인스턴스를 생성합니다. 보시다시피, ApplicationConfiguration에는 `persistence.properties` 에 하드 코딩된 IP 주소 참조가 있습니다.

image::applicationConfiguration-class.png[애플리케이션 구성 클래스]

== 2.2. 외부 구성 문제 수정

이 애플리케이션에서는 레거시 ApplicationConfiguration 클래스를 사용하고 있습니다. 이는 마이그레이션 가이드라인에서 권장하지 않으며 Spring의 `@PropertySource` 주석과 `Environment` 클래스를 사용하는 더 적절한 접근 방식으로 대체해야 합니다.

=== 2.2.1. Spring PropertySource 주석 추가

`PersistenceConfig` 퍼블릭 클래스 위에 다음 주석을 추가합니다.

[.console-input]
[source,java,subs="+attributes,macros+"]
----
@PropertySource("classpath:persistence.properties")
----

=== 2.2.2. DataSource 메서드 업데이트

그런 다음 Spring `@Autowired` 주석을 사용하여 `Environment` 클래스의 인스턴스를 주입하여 로컬 애플리케이션 구성을 참조합니다. 다음 클래스 변수를 _PersistenceConfig_ 클래스에 추가합니다.

[.console-input]
[source,java,subs="+attributes,macros+"]
----
    @Autowired
    private Environment env;
----

_Environment_ 주입을 통해 JDBC configurations을 가져오려면 `dataSource()` 메서드를 다음 코드로 교체하세요.

[.console-input]
[source,java,subs="+attributes,macros+"]
----
    @Bean
    public DataSource dataSource() {
        final DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName(env.getProperty("jdbc.driverClassName"));
        dataSource.setUrl(env.getProperty("jdbc.url"));
        dataSource.setUsername(env.getProperty("jdbc.user"));
        dataSource.setPassword(env.getProperty("jdbc.password"));

        return dataSource;
    }
----

`PersistenceConfig` 클래스는 다음과 같이 보여야 합니다.

image::datasource-modification.png[데이터소스-수정]

=== 2.2.3. additionalProperties 메서드 업데이트

또한 `additionalProperties()` 메서드에서 *ApplicationConfiguration* 참조를 제거해야 합니다. 기존 _additionalProperties_ 메서드를 다음 코드로 교체하세요.

[.console-input]
[source,java,subs="+attributes,macros+"]
----
    final Properties additionalProperties() {
        final Properties hibernateProperties = new Properties();
        hibernateProperties.setProperty("hibernate.hbm2ddl.auto", env.getProperty("hibernate.hbm2ddl.auto"));
        hibernateProperties.setProperty("hibernate.dialect", env.getProperty("hibernate.dialect"));
        hibernateProperties.setProperty("hibernate.cache.use_second_level_cache", "false");

        return hibernateProperties;
    }
----

=== 2.2.4. 패키지 업데이트

불필요한 package imports(예: _ApplicationConfiguration_)를 제거하고 DI 주입 및 PropertySource를 위한 새로운 패키지 이미지를 추가합니다.

이를 수행하는 가장 쉬운 방법은 파일 맨 위의 모든 imports를 다음 imports 세트로 바꾸는 것입니다.

[.console-input]
[source,java,subs="+attributes,macros+"]
----
import java.util.Properties;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.data.web.config.EnableSpringDataWebSupport;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;
----

[IMPORTANT]
====
클래스에서 패키지 이름을 제거하지 않도록 주의하세요. 그러면 최종 결과가 이와 같습니다.
====

[.console-output]
[source,bash,subs="+attributes,macros+"]
----
package io.konveyor.demo.ordermanagement.config;
----

=== 2.2.5. 상용 라이브러리 제거

이러한 변경 사항을 통해 더 이상 외부 상용 라이브러리를 참조할 필요가 없습니다. Maven 프로젝트에서 종속성을 쉽게 제거하거나 주석 처리할 수 있습니다.

`pom.xml` 을 열고 다음 `config-utils` 종속성을 주석 처리(또는 제거)합니다.

[.console-input]
[source,xml,subs="+attributes,macros+"]
----
		<!-- Corporate libraries -->
		<!-- <dependency>
			<groupId>io.konveyor.demo</groupId>
			<artifactId>config-utils</artifactId>
			<version>1.0.0</version>
		</dependency> -->
----

image::comment-dep.png[주석-dep]

=== 2.2.6. application.properties 업데이트

그 사이에 Globex 소매 시스템의 **SRE 팀**은 이미 `Red Hat OpenShift` 를 실행하는 `PostgreSQL 데이터베이스` 를 마이그레이션했습니다.

OpenShift 웹 콘솔의 개발자 관점 탭에서, retail-%USERID% 프로젝트의 link:https://console-openshift-console.%SUBDOMAIN%/topology/ns/retail-%USERID%?view=graph[Topology view^]를 클릭하세요. `postgresql-database` 컨테이너를 볼 수 있습니다.

* 사용자 이름 : `%USERID%`
* 비밀번호: `{openshift-password}`

image::retail-topology.png[주석-종속]

VSCode에서 *src/main/resources* 폴더에 있는 `persistence.properties` 를 열어 OpenShift의 새 *postgresql-customer* 컨테이너에 있는 *customers* 데이터에 액세스합니다.

다음 jdbc.url을 교체합니다.

[.console-input]
[source,properties,subs="+attributes,macros+"]
----
jdbc.url=jdbc:postgresql://postgresql-customer.retail-%USERID%.svc.cluster.local:5432/customer
----

image::update-app-props.png[업데이트-앱-속성]

=== 2.2.7. 빌드 테스트

VS Code 서버에서 `Terminal` 창으로 이동합니다. 그런 다음 customer 애플리케이션을 다시 빌드하고 패키징합니다.

[.console-input]
[source,sh,subs="+attributes,macros+"]
----
cd $HOME/modern-app-dev/customers-tomcat-legacy/ &&
mvn clean package
----

출력은 `BUILD SUCCESS` 로 끝나야 합니다.

[.console-output]
[source,bash,subs="+attributes,macros+"]
----
....
[INFO] Packaging webapp
[INFO] Assembling webapp [customers-tomcat] in [/home/codeserver/modern-app-dev/customers-tomcat-legacy/target/customers-tomcat-0.0.1-SNAPSHOT]
[INFO] Processing war project
[INFO] Building war: /home/codeserver/modern-app-dev/customers-tomcat-legacy/target/customers-tomcat-0.0.1-SNAPSHOT.war
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  15.198 s
[INFO] Finished at: 2024-06-29T02:56:36Z
[INFO] ------------------------------------------------------------------------
----

=== 2.2.8. 변경사항 커밋 및 푸시

MTA 보고서를 분석하기 전에 Gitea 저장소에 변경사항을 커밋하고 푸시해야 합니다. VS Code로 돌아가서 왼쪽의 `Source Control` 메뉴를 선택합니다.

3가지 변화가 보일 것입니다:

* pom.xml
* PersistenceConfig.java
* persistence.properties

코멘트에 `Fix migration issues` 를 입력합니다. `Commit` 을 선택합니다.

image::code-commit.png[코드 커밋]

`Yes` 를 선택하세요.

image::code-commit-yes.png[코드 커밋]

`Sync Changes` 를 선택하세요.

image::sync-changes.png[동기화-변경]

[NOTE]
====
오른쪽 하단에 **Would you like code-server to periodically run "git fetch"? (코드 서버에서 주기적으로 "git fetch"를 실행하시겠습니까?)** 팝업 메시지가 표시될 수 있습니다. 이 메시지는 무시해도 됩니다.
====

link:https://gitea.%SUBDOMAIN%/%USERID%/modern-app-dev/src/branch/ocp-4.15[Gitea repository^]로 돌아가면 커밋이 보일 겁니다. *ocp-4.15* 브랜치를 참조하고 있는지 확인하세요.

image::gitea-commit.png[gitea-커밋]

=== 2.2.9. MTA 분석 다시 실행

link:https://mta-mta-%USERID%.%SUBDOMAIN%/applications/analysis-tab[MTA 분석 웹 콘솔^]로 돌아가서 현대화된 애플리케이션(*customers*)을 분석하기 위한 새 inventory element를 만듭니다.

`Create new` 를 클릭하세요.

image::mta-new-analysis.png[mta-new-analysis]

다음 필드를 입력하고 `Create` 를 클릭하세요.

* Name: `New Customers`
* Description: `Modernized Customers management service`
* Business service: `Retail`
* Tags: `Language / Java`, `Runtime / Tomcat`, `Runtime / Spring Boot`, `Operating System / RHEL 8`, `Database / Postgresql`

* Source code:
** Repository type - `Git`
** Source Repository - `https://gitea.%SUBDOMAIN%/%USERID%/modern-app-dev.git`
** Branch - `ocp-4.15`
** Root path - `customers-tomcat-legacy`

image::mta-new-app.png[mta-new-app]
image::mta-new-app-2.png[mta-new-app]

애플리케이션 인벤토리 페이지로 돌아가면 이름으로 `New Customers` 를 검색합니다. 그런 다음 _New Customers_ 애플리케이션 인벤토리를 선택하고, `Analyze` 를 클릭합니다.

image::mta-search-new-customers.png[mta-search-new-customers]

[NOTE]
====
처음으로 MTA 보고서를 실행하는 경우(예: 모듈 1을 건너뛴 경우) *Administration* view로 가서 *저장소 > Git* 을 선택합니다. *Consume insecure Git repositories* 스위치를 오른쪽으로 토글합니다.

image::mta-admin-git.png[관리자 git]

다음 자격증명을 사용하여 Gitea 저장소에 로그인할 수도 있습니다.

* 사용자 이름 - `%USERID%`
* 비밀번호 - `{openshift-password}`
====

분석 모드 팝업에서 `Source code` 를 선택합니다.

image::add-applications.png[애플리케이션 추가]

`Next` 를 클릭하세요.

이제 변환 대상에 대한 옵션이 표시됩니다. 이전과 마찬가지로 애플리케이션 분석에 대한 매개변수로 `Containers`, `Linux`, `OpenJDK` 를 클릭합니다.

image::configure-analysis-checked.png[분석 구성]

`Next` 를 클릭하세요.

종속성 범위로 `Application and internal dependencies only` (애플리케이션 및 내부 종속성만)을 선택합니다.

image::packages.png[패키지 선택]

`Next` 를 클릭하세요.

이제 사용자 정의 규칙에 대한 옵션이 제공됩니다.

image::custom-rules.png[사용자 정의 규칙]

Gitea 저장소의 *customrules* 디렉토리에 있는 사용자 정의 규칙(`corporate-framework-config.windup.xml`)을 참조하려면 `Repository` 탭을 선택합니다.

repository 페이지에 다음 정보를 입력하세요.

* Repository type - `Git`
* Source Repository - `https://gitea.%SUBDOMAIN%/%USERID%/modern-app-dev.git`
* Branch - `ocp-4.15`
* Root path - `customrules`
* Associated credentials - `None`

[NOTE]
====
`Associated credentials` 에 `None` 이 표시되지 않은 경우, 해당 필드는 필수가 아니므로 그대로 두십시오.
====

image::add-repository-customrules.png[저장소-사용자 정의 규칙 추가]

`Next` 를 클릭하세요.

다음으로, 기본 옵션을 사용하려면 `Advanced options` 에서 그냥 `Next` 를 클릭하세요.

image::fine-tune.png[미세조정]

마지막으로, 분석을 위한 구성 요약을 제공합니다.

image::finish-project.png[프로젝트 완료]

`Run` 을 클릭하세요.

이제 새로운 분석이 시작되고 완료되면 보고서에 액세스할 수 있습니다. 분석이 완료될 때까지 이 뷰에 머물러 있습니다.

[NOTE]
====
분석을 위해 Windup 이미지를 가져오고 애플리케이션 분석을 실행하는 데 몇 분이 걸립니다.
====

image::new-active-analysis.png[활성 분석]

*Customers* 애플리케이션을 선택합니다. 그런 다음 오른쪽의 *Details* 탭에서 `Issues` 를 클릭합니다.

image::new-active-analysis-report.png[활성 분석]

Customers Service 프로젝트에 사용한 것과 동일한 설정과 사용자 지정 규칙으로 프로젝트를 구성합니다. 보고서가 완료되면 애플리케이션에 `issues` 가 없음을 확인합니다.

## 축하합니다!

이 앱을 성공적으로 마이그레이션했으며 이제 OpenShift에 배포할 준비가 되었습니다. 

image::new-report-solution-view.png[새로운 뷰 보고서]
